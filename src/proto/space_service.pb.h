// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: space_service.proto
// Protobuf C++ Version: 5.27.0

#ifndef GOOGLE_PROTOBUF_INCLUDED_space_5fservice_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_space_5fservice_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5027000
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_space_5fservice_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_space_5fservice_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_space_5fservice_2eproto;
namespace space_service {
class Animation;
struct AnimationDefaultTypeInternal;
extern AnimationDefaultTypeInternal _Animation_default_instance_;
class AoiEntity;
struct AoiEntityDefaultTypeInternal;
extern AoiEntityDefaultTypeInternal _AoiEntity_default_instance_;
class AoiUpdate;
struct AoiUpdateDefaultTypeInternal;
extern AoiUpdateDefaultTypeInternal _AoiUpdate_default_instance_;
class AoiUpdates;
struct AoiUpdatesDefaultTypeInternal;
extern AoiUpdatesDefaultTypeInternal _AoiUpdates_default_instance_;
class EntitiesEnterSight;
struct EntitiesEnterSightDefaultTypeInternal;
extern EntitiesEnterSightDefaultTypeInternal _EntitiesEnterSight_default_instance_;
class EntitiesLeaveSight;
struct EntitiesLeaveSightDefaultTypeInternal;
extern EntitiesLeaveSightDefaultTypeInternal _EntitiesLeaveSight_default_instance_;
class JoinReply;
struct JoinReplyDefaultTypeInternal;
extern JoinReplyDefaultTypeInternal _JoinReply_default_instance_;
class LoginReply;
struct LoginReplyDefaultTypeInternal;
extern LoginReplyDefaultTypeInternal _LoginReply_default_instance_;
class LoginRequest;
struct LoginRequestDefaultTypeInternal;
extern LoginRequestDefaultTypeInternal _LoginRequest_default_instance_;
class Movement;
struct MovementDefaultTypeInternal;
extern MovementDefaultTypeInternal _Movement_default_instance_;
class NormalAttack;
struct NormalAttackDefaultTypeInternal;
extern NormalAttackDefaultTypeInternal _NormalAttack_default_instance_;
class Ping;
struct PingDefaultTypeInternal;
extern PingDefaultTypeInternal _Ping_default_instance_;
class PlayerAnimation;
struct PlayerAnimationDefaultTypeInternal;
extern PlayerAnimationDefaultTypeInternal _PlayerAnimation_default_instance_;
class PlayerDeltaInfo;
struct PlayerDeltaInfoDefaultTypeInternal;
extern PlayerDeltaInfoDefaultTypeInternal _PlayerDeltaInfo_default_instance_;
class PlayerInfo;
struct PlayerInfoDefaultTypeInternal;
extern PlayerInfoDefaultTypeInternal _PlayerInfo_default_instance_;
class Pong;
struct PongDefaultTypeInternal;
extern PongDefaultTypeInternal _Pong_default_instance_;
class QueryPath;
struct QueryPathDefaultTypeInternal;
extern QueryPathDefaultTypeInternal _QueryPath_default_instance_;
class QueryPathResult;
struct QueryPathResultDefaultTypeInternal;
extern QueryPathResultDefaultTypeInternal _QueryPathResult_default_instance_;
class SkillAttack;
struct SkillAttackDefaultTypeInternal;
extern SkillAttackDefaultTypeInternal _SkillAttack_default_instance_;
class TakeDamage;
struct TakeDamageDefaultTypeInternal;
extern TakeDamageDefaultTypeInternal _TakeDamage_default_instance_;
class Vector3f;
struct Vector3fDefaultTypeInternal;
extern Vector3fDefaultTypeInternal _Vector3f_default_instance_;
}  // namespace space_service
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace space_service {
enum Animation_OperationType : int {
  Animation_OperationType_START = 0,
  Animation_OperationType_STOP = 1,
  Animation_OperationType_UPDATE = 2,
  Animation_OperationType_Animation_OperationType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Animation_OperationType_Animation_OperationType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Animation_OperationType_IsValid(int value);
extern const uint32_t Animation_OperationType_internal_data_[];
constexpr Animation_OperationType Animation_OperationType_OperationType_MIN = static_cast<Animation_OperationType>(0);
constexpr Animation_OperationType Animation_OperationType_OperationType_MAX = static_cast<Animation_OperationType>(2);
constexpr int Animation_OperationType_OperationType_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
Animation_OperationType_descriptor();
template <typename T>
const std::string& Animation_OperationType_Name(T value) {
  static_assert(std::is_same<T, Animation_OperationType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to OperationType_Name().");
  return Animation_OperationType_Name(static_cast<Animation_OperationType>(value));
}
template <>
inline const std::string& Animation_OperationType_Name(Animation_OperationType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Animation_OperationType_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool Animation_OperationType_Parse(absl::string_view name, Animation_OperationType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Animation_OperationType>(
      Animation_OperationType_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class Vector3f final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:space_service.Vector3f) */ {
 public:
  inline Vector3f() : Vector3f(nullptr) {}
  ~Vector3f() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Vector3f(
      ::google::protobuf::internal::ConstantInitialized);

  inline Vector3f(const Vector3f& from) : Vector3f(nullptr, from) {}
  inline Vector3f(Vector3f&& from) noexcept
      : Vector3f(nullptr, std::move(from)) {}
  inline Vector3f& operator=(const Vector3f& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vector3f& operator=(Vector3f&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Vector3f& default_instance() {
    return *internal_default_instance();
  }
  static inline const Vector3f* internal_default_instance() {
    return reinterpret_cast<const Vector3f*>(
        &_Vector3f_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(Vector3f& a, Vector3f& b) { a.Swap(&b); }
  inline void Swap(Vector3f* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vector3f* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Vector3f* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<Vector3f>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Vector3f& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Vector3f& from) { Vector3f::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Vector3f* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "space_service.Vector3f"; }

 protected:
  explicit Vector3f(::google::protobuf::Arena* arena);
  Vector3f(::google::protobuf::Arena* arena, const Vector3f& from);
  Vector3f(::google::protobuf::Arena* arena, Vector3f&& from) noexcept
      : Vector3f(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // float x = 1;
  void clear_x() ;
  float x() const;
  void set_x(float value);

  private:
  float _internal_x() const;
  void _internal_set_x(float value);

  public:
  // float y = 2;
  void clear_y() ;
  float y() const;
  void set_y(float value);

  private:
  float _internal_y() const;
  void _internal_set_y(float value);

  public:
  // float z = 3;
  void clear_z() ;
  float z() const;
  void set_z(float value);

  private:
  float _internal_z() const;
  void _internal_set_z(float value);

  public:
  // @@protoc_insertion_point(class_scope:space_service.Vector3f)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Vector3f_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Vector3f& from_msg);
    float x_;
    float y_;
    float z_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_space_5fservice_2eproto;
};
// -------------------------------------------------------------------

class TakeDamage final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:space_service.TakeDamage) */ {
 public:
  inline TakeDamage() : TakeDamage(nullptr) {}
  ~TakeDamage() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TakeDamage(
      ::google::protobuf::internal::ConstantInitialized);

  inline TakeDamage(const TakeDamage& from) : TakeDamage(nullptr, from) {}
  inline TakeDamage(TakeDamage&& from) noexcept
      : TakeDamage(nullptr, std::move(from)) {}
  inline TakeDamage& operator=(const TakeDamage& from) {
    CopyFrom(from);
    return *this;
  }
  inline TakeDamage& operator=(TakeDamage&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TakeDamage& default_instance() {
    return *internal_default_instance();
  }
  static inline const TakeDamage* internal_default_instance() {
    return reinterpret_cast<const TakeDamage*>(
        &_TakeDamage_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 18;
  friend void swap(TakeDamage& a, TakeDamage& b) { a.Swap(&b); }
  inline void Swap(TakeDamage* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TakeDamage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TakeDamage* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<TakeDamage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TakeDamage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TakeDamage& from) { TakeDamage::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TakeDamage* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "space_service.TakeDamage"; }

 protected:
  explicit TakeDamage(::google::protobuf::Arena* arena);
  TakeDamage(::google::protobuf::Arena* arena, const TakeDamage& from);
  TakeDamage(::google::protobuf::Arena* arena, TakeDamage&& from) noexcept
      : TakeDamage(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEidFieldNumber = 1,
    kDamageFieldNumber = 2,
  };
  // int32 eid = 1;
  void clear_eid() ;
  ::int32_t eid() const;
  void set_eid(::int32_t value);

  private:
  ::int32_t _internal_eid() const;
  void _internal_set_eid(::int32_t value);

  public:
  // int32 damage = 2;
  void clear_damage() ;
  ::int32_t damage() const;
  void set_damage(::int32_t value);

  private:
  ::int32_t _internal_damage() const;
  void _internal_set_damage(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:space_service.TakeDamage)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_TakeDamage_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const TakeDamage& from_msg);
    ::int32_t eid_;
    ::int32_t damage_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_space_5fservice_2eproto;
};
// -------------------------------------------------------------------

class SkillAttack final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:space_service.SkillAttack) */ {
 public:
  inline SkillAttack() : SkillAttack(nullptr) {}
  ~SkillAttack() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SkillAttack(
      ::google::protobuf::internal::ConstantInitialized);

  inline SkillAttack(const SkillAttack& from) : SkillAttack(nullptr, from) {}
  inline SkillAttack(SkillAttack&& from) noexcept
      : SkillAttack(nullptr, std::move(from)) {}
  inline SkillAttack& operator=(const SkillAttack& from) {
    CopyFrom(from);
    return *this;
  }
  inline SkillAttack& operator=(SkillAttack&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SkillAttack& default_instance() {
    return *internal_default_instance();
  }
  static inline const SkillAttack* internal_default_instance() {
    return reinterpret_cast<const SkillAttack*>(
        &_SkillAttack_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 15;
  friend void swap(SkillAttack& a, SkillAttack& b) { a.Swap(&b); }
  inline void Swap(SkillAttack* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SkillAttack* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SkillAttack* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<SkillAttack>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SkillAttack& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SkillAttack& from) { SkillAttack::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SkillAttack* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "space_service.SkillAttack"; }

 protected:
  explicit SkillAttack(::google::protobuf::Arena* arena);
  SkillAttack(::google::protobuf::Arena* arena, const SkillAttack& from);
  SkillAttack(::google::protobuf::Arena* arena, SkillAttack&& from) noexcept
      : SkillAttack(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSkillIdFieldNumber = 1,
  };
  // int32 skill_id = 1;
  void clear_skill_id() ;
  ::int32_t skill_id() const;
  void set_skill_id(::int32_t value);

  private:
  ::int32_t _internal_skill_id() const;
  void _internal_set_skill_id(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:space_service.SkillAttack)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_SkillAttack_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SkillAttack& from_msg);
    ::int32_t skill_id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_space_5fservice_2eproto;
};
// -------------------------------------------------------------------

class Pong final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:space_service.Pong) */ {
 public:
  inline Pong() : Pong(nullptr) {}
  ~Pong() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Pong(
      ::google::protobuf::internal::ConstantInitialized);

  inline Pong(const Pong& from) : Pong(nullptr, from) {}
  inline Pong(Pong&& from) noexcept
      : Pong(nullptr, std::move(from)) {}
  inline Pong& operator=(const Pong& from) {
    CopyFrom(from);
    return *this;
  }
  inline Pong& operator=(Pong&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Pong& default_instance() {
    return *internal_default_instance();
  }
  static inline const Pong* internal_default_instance() {
    return reinterpret_cast<const Pong*>(
        &_Pong_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 13;
  friend void swap(Pong& a, Pong& b) { a.Swap(&b); }
  inline void Swap(Pong* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Pong* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Pong* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<Pong>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Pong& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Pong& from) { Pong::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Pong* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "space_service.Pong"; }

 protected:
  explicit Pong(::google::protobuf::Arena* arena);
  Pong(::google::protobuf::Arena* arena, const Pong& from);
  Pong(::google::protobuf::Arena* arena, Pong&& from) noexcept
      : Pong(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTFieldNumber = 1,
    kServerTFieldNumber = 2,
  };
  // float t = 1;
  void clear_t() ;
  float t() const;
  void set_t(float value);

  private:
  float _internal_t() const;
  void _internal_set_t(float value);

  public:
  // int32 server_t = 2;
  void clear_server_t() ;
  ::int32_t server_t() const;
  void set_server_t(::int32_t value);

  private:
  ::int32_t _internal_server_t() const;
  void _internal_set_server_t(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:space_service.Pong)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Pong_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Pong& from_msg);
    float t_;
    ::int32_t server_t_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_space_5fservice_2eproto;
};
// -------------------------------------------------------------------

class PlayerInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:space_service.PlayerInfo) */ {
 public:
  inline PlayerInfo() : PlayerInfo(nullptr) {}
  ~PlayerInfo() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PlayerInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline PlayerInfo(const PlayerInfo& from) : PlayerInfo(nullptr, from) {}
  inline PlayerInfo(PlayerInfo&& from) noexcept
      : PlayerInfo(nullptr, std::move(from)) {}
  inline PlayerInfo& operator=(const PlayerInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerInfo& operator=(PlayerInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerInfo* internal_default_instance() {
    return reinterpret_cast<const PlayerInfo*>(
        &_PlayerInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(PlayerInfo& a, PlayerInfo& b) { a.Swap(&b); }
  inline void Swap(PlayerInfo* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<PlayerInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PlayerInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PlayerInfo& from) { PlayerInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PlayerInfo* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "space_service.PlayerInfo"; }

 protected:
  explicit PlayerInfo(::google::protobuf::Arena* arena);
  PlayerInfo(::google::protobuf::Arena* arena, const PlayerInfo& from);
  PlayerInfo(::google::protobuf::Arena* arena, PlayerInfo&& from) noexcept
      : PlayerInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDataFieldNumber = 2,
    kEidFieldNumber = 1,
  };
  // bytes data = 2;
  void clear_data() ;
  const std::string& data() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_data(Arg_&& arg, Args_... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* value);

  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(
      const std::string& value);
  std::string* _internal_mutable_data();

  public:
  // int32 eid = 1;
  void clear_eid() ;
  ::int32_t eid() const;
  void set_eid(::int32_t value);

  private:
  ::int32_t _internal_eid() const;
  void _internal_set_eid(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:space_service.PlayerInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_PlayerInfo_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const PlayerInfo& from_msg);
    ::google::protobuf::internal::ArenaStringPtr data_;
    ::int32_t eid_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_space_5fservice_2eproto;
};
// -------------------------------------------------------------------

class PlayerDeltaInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:space_service.PlayerDeltaInfo) */ {
 public:
  inline PlayerDeltaInfo() : PlayerDeltaInfo(nullptr) {}
  ~PlayerDeltaInfo() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PlayerDeltaInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline PlayerDeltaInfo(const PlayerDeltaInfo& from) : PlayerDeltaInfo(nullptr, from) {}
  inline PlayerDeltaInfo(PlayerDeltaInfo&& from) noexcept
      : PlayerDeltaInfo(nullptr, std::move(from)) {}
  inline PlayerDeltaInfo& operator=(const PlayerDeltaInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerDeltaInfo& operator=(PlayerDeltaInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerDeltaInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerDeltaInfo* internal_default_instance() {
    return reinterpret_cast<const PlayerDeltaInfo*>(
        &_PlayerDeltaInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(PlayerDeltaInfo& a, PlayerDeltaInfo& b) { a.Swap(&b); }
  inline void Swap(PlayerDeltaInfo* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerDeltaInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerDeltaInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<PlayerDeltaInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PlayerDeltaInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PlayerDeltaInfo& from) { PlayerDeltaInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PlayerDeltaInfo* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "space_service.PlayerDeltaInfo"; }

 protected:
  explicit PlayerDeltaInfo(::google::protobuf::Arena* arena);
  PlayerDeltaInfo(::google::protobuf::Arena* arena, const PlayerDeltaInfo& from);
  PlayerDeltaInfo(::google::protobuf::Arena* arena, PlayerDeltaInfo&& from) noexcept
      : PlayerDeltaInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDataFieldNumber = 2,
    kEidFieldNumber = 1,
  };
  // bytes data = 2;
  void clear_data() ;
  const std::string& data() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_data(Arg_&& arg, Args_... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* value);

  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(
      const std::string& value);
  std::string* _internal_mutable_data();

  public:
  // int32 eid = 1;
  void clear_eid() ;
  ::int32_t eid() const;
  void set_eid(::int32_t value);

  private:
  ::int32_t _internal_eid() const;
  void _internal_set_eid(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:space_service.PlayerDeltaInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_PlayerDeltaInfo_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const PlayerDeltaInfo& from_msg);
    ::google::protobuf::internal::ArenaStringPtr data_;
    ::int32_t eid_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_space_5fservice_2eproto;
};
// -------------------------------------------------------------------

class Ping final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:space_service.Ping) */ {
 public:
  inline Ping() : Ping(nullptr) {}
  ~Ping() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Ping(
      ::google::protobuf::internal::ConstantInitialized);

  inline Ping(const Ping& from) : Ping(nullptr, from) {}
  inline Ping(Ping&& from) noexcept
      : Ping(nullptr, std::move(from)) {}
  inline Ping& operator=(const Ping& from) {
    CopyFrom(from);
    return *this;
  }
  inline Ping& operator=(Ping&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Ping& default_instance() {
    return *internal_default_instance();
  }
  static inline const Ping* internal_default_instance() {
    return reinterpret_cast<const Ping*>(
        &_Ping_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 12;
  friend void swap(Ping& a, Ping& b) { a.Swap(&b); }
  inline void Swap(Ping* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Ping* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Ping* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<Ping>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Ping& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Ping& from) { Ping::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Ping* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "space_service.Ping"; }

 protected:
  explicit Ping(::google::protobuf::Arena* arena);
  Ping(::google::protobuf::Arena* arena, const Ping& from);
  Ping(::google::protobuf::Arena* arena, Ping&& from) noexcept
      : Ping(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTFieldNumber = 1,
  };
  // float t = 1;
  void clear_t() ;
  float t() const;
  void set_t(float value);

  private:
  float _internal_t() const;
  void _internal_set_t(float value);

  public:
  // @@protoc_insertion_point(class_scope:space_service.Ping)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Ping_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Ping& from_msg);
    float t_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_space_5fservice_2eproto;
};
// -------------------------------------------------------------------

class NormalAttack final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:space_service.NormalAttack) */ {
 public:
  inline NormalAttack() : NormalAttack(nullptr) {}
  ~NormalAttack() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NormalAttack(
      ::google::protobuf::internal::ConstantInitialized);

  inline NormalAttack(const NormalAttack& from) : NormalAttack(nullptr, from) {}
  inline NormalAttack(NormalAttack&& from) noexcept
      : NormalAttack(nullptr, std::move(from)) {}
  inline NormalAttack& operator=(const NormalAttack& from) {
    CopyFrom(from);
    return *this;
  }
  inline NormalAttack& operator=(NormalAttack&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NormalAttack& default_instance() {
    return *internal_default_instance();
  }
  static inline const NormalAttack* internal_default_instance() {
    return reinterpret_cast<const NormalAttack*>(
        &_NormalAttack_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 14;
  friend void swap(NormalAttack& a, NormalAttack& b) { a.Swap(&b); }
  inline void Swap(NormalAttack* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NormalAttack* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NormalAttack* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<NormalAttack>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NormalAttack& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NormalAttack& from) { NormalAttack::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NormalAttack* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "space_service.NormalAttack"; }

 protected:
  explicit NormalAttack(::google::protobuf::Arena* arena);
  NormalAttack(::google::protobuf::Arena* arena, const NormalAttack& from);
  NormalAttack(::google::protobuf::Arena* arena, NormalAttack&& from) noexcept
      : NormalAttack(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kComboFieldNumber = 1,
  };
  // int32 combo = 1;
  void clear_combo() ;
  ::int32_t combo() const;
  void set_combo(::int32_t value);

  private:
  ::int32_t _internal_combo() const;
  void _internal_set_combo(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:space_service.NormalAttack)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_NormalAttack_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const NormalAttack& from_msg);
    ::int32_t combo_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_space_5fservice_2eproto;
};
// -------------------------------------------------------------------

class LoginRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:space_service.LoginRequest) */ {
 public:
  inline LoginRequest() : LoginRequest(nullptr) {}
  ~LoginRequest() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR LoginRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline LoginRequest(const LoginRequest& from) : LoginRequest(nullptr, from) {}
  inline LoginRequest(LoginRequest&& from) noexcept
      : LoginRequest(nullptr, std::move(from)) {}
  inline LoginRequest& operator=(const LoginRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginRequest& operator=(LoginRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoginRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoginRequest* internal_default_instance() {
    return reinterpret_cast<const LoginRequest*>(
        &_LoginRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(LoginRequest& a, LoginRequest& b) { a.Swap(&b); }
  inline void Swap(LoginRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<LoginRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const LoginRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const LoginRequest& from) { LoginRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(LoginRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "space_service.LoginRequest"; }

 protected:
  explicit LoginRequest(::google::protobuf::Arena* arena);
  LoginRequest(::google::protobuf::Arena* arena, const LoginRequest& from);
  LoginRequest(::google::protobuf::Arena* arena, LoginRequest&& from) noexcept
      : LoginRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kUsernameFieldNumber = 1,
  };
  // string username = 1;
  void clear_username() ;
  const std::string& username() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_username(Arg_&& arg, Args_... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* value);

  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(
      const std::string& value);
  std::string* _internal_mutable_username();

  public:
  // @@protoc_insertion_point(class_scope:space_service.LoginRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      43, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_LoginRequest_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const LoginRequest& from_msg);
    ::google::protobuf::internal::ArenaStringPtr username_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_space_5fservice_2eproto;
};
// -------------------------------------------------------------------

class LoginReply final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:space_service.LoginReply) */ {
 public:
  inline LoginReply() : LoginReply(nullptr) {}
  ~LoginReply() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR LoginReply(
      ::google::protobuf::internal::ConstantInitialized);

  inline LoginReply(const LoginReply& from) : LoginReply(nullptr, from) {}
  inline LoginReply(LoginReply&& from) noexcept
      : LoginReply(nullptr, std::move(from)) {}
  inline LoginReply& operator=(const LoginReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginReply& operator=(LoginReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoginReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoginReply* internal_default_instance() {
    return reinterpret_cast<const LoginReply*>(
        &_LoginReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(LoginReply& a, LoginReply& b) { a.Swap(&b); }
  inline void Swap(LoginReply* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginReply* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginReply* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<LoginReply>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const LoginReply& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const LoginReply& from) { LoginReply::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(LoginReply* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "space_service.LoginReply"; }

 protected:
  explicit LoginReply(::google::protobuf::Arena* arena);
  LoginReply(::google::protobuf::Arena* arena, const LoginReply& from);
  LoginReply(::google::protobuf::Arena* arena, LoginReply&& from) noexcept
      : LoginReply(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kResultFieldNumber = 1,
    kEidFieldNumber = 2,
  };
  // int32 result = 1;
  void clear_result() ;
  ::int32_t result() const;
  void set_result(::int32_t value);

  private:
  ::int32_t _internal_result() const;
  void _internal_set_result(::int32_t value);

  public:
  // int32 eid = 2;
  void clear_eid() ;
  ::int32_t eid() const;
  void set_eid(::int32_t value);

  private:
  ::int32_t _internal_eid() const;
  void _internal_set_eid(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:space_service.LoginReply)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_LoginReply_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const LoginReply& from_msg);
    ::int32_t result_;
    ::int32_t eid_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_space_5fservice_2eproto;
};
// -------------------------------------------------------------------

class EntitiesLeaveSight final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:space_service.EntitiesLeaveSight) */ {
 public:
  inline EntitiesLeaveSight() : EntitiesLeaveSight(nullptr) {}
  ~EntitiesLeaveSight() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR EntitiesLeaveSight(
      ::google::protobuf::internal::ConstantInitialized);

  inline EntitiesLeaveSight(const EntitiesLeaveSight& from) : EntitiesLeaveSight(nullptr, from) {}
  inline EntitiesLeaveSight(EntitiesLeaveSight&& from) noexcept
      : EntitiesLeaveSight(nullptr, std::move(from)) {}
  inline EntitiesLeaveSight& operator=(const EntitiesLeaveSight& from) {
    CopyFrom(from);
    return *this;
  }
  inline EntitiesLeaveSight& operator=(EntitiesLeaveSight&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EntitiesLeaveSight& default_instance() {
    return *internal_default_instance();
  }
  static inline const EntitiesLeaveSight* internal_default_instance() {
    return reinterpret_cast<const EntitiesLeaveSight*>(
        &_EntitiesLeaveSight_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(EntitiesLeaveSight& a, EntitiesLeaveSight& b) { a.Swap(&b); }
  inline void Swap(EntitiesLeaveSight* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EntitiesLeaveSight* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EntitiesLeaveSight* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<EntitiesLeaveSight>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EntitiesLeaveSight& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const EntitiesLeaveSight& from) { EntitiesLeaveSight::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(EntitiesLeaveSight* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "space_service.EntitiesLeaveSight"; }

 protected:
  explicit EntitiesLeaveSight(::google::protobuf::Arena* arena);
  EntitiesLeaveSight(::google::protobuf::Arena* arena, const EntitiesLeaveSight& from);
  EntitiesLeaveSight(::google::protobuf::Arena* arena, EntitiesLeaveSight&& from) noexcept
      : EntitiesLeaveSight(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEntitiesFieldNumber = 1,
  };
  // repeated int32 entities = 1;
  int entities_size() const;
  private:
  int _internal_entities_size() const;

  public:
  void clear_entities() ;
  ::int32_t entities(int index) const;
  void set_entities(int index, ::int32_t value);
  void add_entities(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& entities() const;
  ::google::protobuf::RepeatedField<::int32_t>* mutable_entities();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_entities() const;
  ::google::protobuf::RepeatedField<::int32_t>* _internal_mutable_entities();

  public:
  // @@protoc_insertion_point(class_scope:space_service.EntitiesLeaveSight)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_EntitiesLeaveSight_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const EntitiesLeaveSight& from_msg);
    ::google::protobuf::RepeatedField<::int32_t> entities_;
    mutable ::google::protobuf::internal::CachedSize _entities_cached_byte_size_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_space_5fservice_2eproto;
};
// -------------------------------------------------------------------

class AoiUpdate final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:space_service.AoiUpdate) */ {
 public:
  inline AoiUpdate() : AoiUpdate(nullptr) {}
  ~AoiUpdate() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AoiUpdate(
      ::google::protobuf::internal::ConstantInitialized);

  inline AoiUpdate(const AoiUpdate& from) : AoiUpdate(nullptr, from) {}
  inline AoiUpdate(AoiUpdate&& from) noexcept
      : AoiUpdate(nullptr, std::move(from)) {}
  inline AoiUpdate& operator=(const AoiUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  inline AoiUpdate& operator=(AoiUpdate&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AoiUpdate& default_instance() {
    return *internal_default_instance();
  }
  static inline const AoiUpdate* internal_default_instance() {
    return reinterpret_cast<const AoiUpdate*>(
        &_AoiUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(AoiUpdate& a, AoiUpdate& b) { a.Swap(&b); }
  inline void Swap(AoiUpdate* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AoiUpdate* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AoiUpdate* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<AoiUpdate>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AoiUpdate& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AoiUpdate& from) { AoiUpdate::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AoiUpdate* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "space_service.AoiUpdate"; }

 protected:
  explicit AoiUpdate(::google::protobuf::Arena* arena);
  AoiUpdate(::google::protobuf::Arena* arena, const AoiUpdate& from);
  AoiUpdate(::google::protobuf::Arena* arena, AoiUpdate&& from) noexcept
      : AoiUpdate(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDataFieldNumber = 2,
    kEidFieldNumber = 1,
  };
  // optional bytes data = 2;
  bool has_data() const;
  void clear_data() ;
  const std::string& data() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_data(Arg_&& arg, Args_... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* value);

  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(
      const std::string& value);
  std::string* _internal_mutable_data();

  public:
  // int32 eid = 1;
  void clear_eid() ;
  ::int32_t eid() const;
  void set_eid(::int32_t value);

  private:
  ::int32_t _internal_eid() const;
  void _internal_set_eid(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:space_service.AoiUpdate)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_AoiUpdate_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const AoiUpdate& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr data_;
    ::int32_t eid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_space_5fservice_2eproto;
};
// -------------------------------------------------------------------

class Animation final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:space_service.Animation) */ {
 public:
  inline Animation() : Animation(nullptr) {}
  ~Animation() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Animation(
      ::google::protobuf::internal::ConstantInitialized);

  inline Animation(const Animation& from) : Animation(nullptr, from) {}
  inline Animation(Animation&& from) noexcept
      : Animation(nullptr, std::move(from)) {}
  inline Animation& operator=(const Animation& from) {
    CopyFrom(from);
    return *this;
  }
  inline Animation& operator=(Animation&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Animation& default_instance() {
    return *internal_default_instance();
  }
  static inline const Animation* internal_default_instance() {
    return reinterpret_cast<const Animation*>(
        &_Animation_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 16;
  friend void swap(Animation& a, Animation& b) { a.Swap(&b); }
  inline void Swap(Animation* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Animation* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Animation* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<Animation>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Animation& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Animation& from) { Animation::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Animation* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "space_service.Animation"; }

 protected:
  explicit Animation(::google::protobuf::Arena* arena);
  Animation(::google::protobuf::Arena* arena, const Animation& from);
  Animation(::google::protobuf::Arena* arena, Animation&& from) noexcept
      : Animation(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using OperationType = Animation_OperationType;
  static constexpr OperationType START = Animation_OperationType_START;
  static constexpr OperationType STOP = Animation_OperationType_STOP;
  static constexpr OperationType UPDATE = Animation_OperationType_UPDATE;
  static inline bool OperationType_IsValid(int value) {
    return Animation_OperationType_IsValid(value);
  }
  static constexpr OperationType OperationType_MIN = Animation_OperationType_OperationType_MIN;
  static constexpr OperationType OperationType_MAX = Animation_OperationType_OperationType_MAX;
  static constexpr int OperationType_ARRAYSIZE = Animation_OperationType_OperationType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* OperationType_descriptor() {
    return Animation_OperationType_descriptor();
  }
  template <typename T>
  static inline const std::string& OperationType_Name(T value) {
    return Animation_OperationType_Name(value);
  }
  static inline bool OperationType_Parse(absl::string_view name, OperationType* value) {
    return Animation_OperationType_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kNameFieldNumber = 1,
    kOpFieldNumber = 2,
    kSpeedFieldNumber = 3,
  };
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // .space_service.Animation.OperationType op = 2;
  void clear_op() ;
  ::space_service::Animation_OperationType op() const;
  void set_op(::space_service::Animation_OperationType value);

  private:
  ::space_service::Animation_OperationType _internal_op() const;
  void _internal_set_op(::space_service::Animation_OperationType value);

  public:
  // float speed = 3;
  void clear_speed() ;
  float speed() const;
  void set_speed(float value);

  private:
  float _internal_speed() const;
  void _internal_set_speed(float value);

  public:
  // @@protoc_insertion_point(class_scope:space_service.Animation)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      36, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Animation_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Animation& from_msg);
    ::google::protobuf::internal::ArenaStringPtr name_;
    int op_;
    float speed_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_space_5fservice_2eproto;
};
// -------------------------------------------------------------------

class QueryPathResult final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:space_service.QueryPathResult) */ {
 public:
  inline QueryPathResult() : QueryPathResult(nullptr) {}
  ~QueryPathResult() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR QueryPathResult(
      ::google::protobuf::internal::ConstantInitialized);

  inline QueryPathResult(const QueryPathResult& from) : QueryPathResult(nullptr, from) {}
  inline QueryPathResult(QueryPathResult&& from) noexcept
      : QueryPathResult(nullptr, std::move(from)) {}
  inline QueryPathResult& operator=(const QueryPathResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryPathResult& operator=(QueryPathResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryPathResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryPathResult* internal_default_instance() {
    return reinterpret_cast<const QueryPathResult*>(
        &_QueryPathResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 20;
  friend void swap(QueryPathResult& a, QueryPathResult& b) { a.Swap(&b); }
  inline void Swap(QueryPathResult* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryPathResult* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryPathResult* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<QueryPathResult>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const QueryPathResult& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const QueryPathResult& from) { QueryPathResult::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(QueryPathResult* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "space_service.QueryPathResult"; }

 protected:
  explicit QueryPathResult(::google::protobuf::Arena* arena);
  QueryPathResult(::google::protobuf::Arena* arena, const QueryPathResult& from);
  QueryPathResult(::google::protobuf::Arena* arena, QueryPathResult&& from) noexcept
      : QueryPathResult(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPathsFieldNumber = 1,
  };
  // repeated .space_service.Vector3f paths = 1;
  int paths_size() const;
  private:
  int _internal_paths_size() const;

  public:
  void clear_paths() ;
  ::space_service::Vector3f* mutable_paths(int index);
  ::google::protobuf::RepeatedPtrField<::space_service::Vector3f>* mutable_paths();

  private:
  const ::google::protobuf::RepeatedPtrField<::space_service::Vector3f>& _internal_paths() const;
  ::google::protobuf::RepeatedPtrField<::space_service::Vector3f>* _internal_mutable_paths();
  public:
  const ::space_service::Vector3f& paths(int index) const;
  ::space_service::Vector3f* add_paths();
  const ::google::protobuf::RepeatedPtrField<::space_service::Vector3f>& paths() const;
  // @@protoc_insertion_point(class_scope:space_service.QueryPathResult)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_QueryPathResult_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const QueryPathResult& from_msg);
    ::google::protobuf::RepeatedPtrField< ::space_service::Vector3f > paths_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_space_5fservice_2eproto;
};
// -------------------------------------------------------------------

class QueryPath final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:space_service.QueryPath) */ {
 public:
  inline QueryPath() : QueryPath(nullptr) {}
  ~QueryPath() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR QueryPath(
      ::google::protobuf::internal::ConstantInitialized);

  inline QueryPath(const QueryPath& from) : QueryPath(nullptr, from) {}
  inline QueryPath(QueryPath&& from) noexcept
      : QueryPath(nullptr, std::move(from)) {}
  inline QueryPath& operator=(const QueryPath& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryPath& operator=(QueryPath&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryPath& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryPath* internal_default_instance() {
    return reinterpret_cast<const QueryPath*>(
        &_QueryPath_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 19;
  friend void swap(QueryPath& a, QueryPath& b) { a.Swap(&b); }
  inline void Swap(QueryPath* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryPath* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryPath* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<QueryPath>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const QueryPath& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const QueryPath& from) { QueryPath::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(QueryPath* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "space_service.QueryPath"; }

 protected:
  explicit QueryPath(::google::protobuf::Arena* arena);
  QueryPath(::google::protobuf::Arena* arena, const QueryPath& from);
  QueryPath(::google::protobuf::Arena* arena, QueryPath&& from) noexcept
      : QueryPath(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kStartPosFieldNumber = 1,
    kEndPosFieldNumber = 2,
  };
  // .space_service.Vector3f start_pos = 1;
  bool has_start_pos() const;
  void clear_start_pos() ;
  const ::space_service::Vector3f& start_pos() const;
  PROTOBUF_NODISCARD ::space_service::Vector3f* release_start_pos();
  ::space_service::Vector3f* mutable_start_pos();
  void set_allocated_start_pos(::space_service::Vector3f* value);
  void unsafe_arena_set_allocated_start_pos(::space_service::Vector3f* value);
  ::space_service::Vector3f* unsafe_arena_release_start_pos();

  private:
  const ::space_service::Vector3f& _internal_start_pos() const;
  ::space_service::Vector3f* _internal_mutable_start_pos();

  public:
  // .space_service.Vector3f end_pos = 2;
  bool has_end_pos() const;
  void clear_end_pos() ;
  const ::space_service::Vector3f& end_pos() const;
  PROTOBUF_NODISCARD ::space_service::Vector3f* release_end_pos();
  ::space_service::Vector3f* mutable_end_pos();
  void set_allocated_end_pos(::space_service::Vector3f* value);
  void unsafe_arena_set_allocated_end_pos(::space_service::Vector3f* value);
  ::space_service::Vector3f* unsafe_arena_release_end_pos();

  private:
  const ::space_service::Vector3f& _internal_end_pos() const;
  ::space_service::Vector3f* _internal_mutable_end_pos();

  public:
  // @@protoc_insertion_point(class_scope:space_service.QueryPath)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_QueryPath_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const QueryPath& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::space_service::Vector3f* start_pos_;
    ::space_service::Vector3f* end_pos_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_space_5fservice_2eproto;
};
// -------------------------------------------------------------------

class PlayerAnimation final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:space_service.PlayerAnimation) */ {
 public:
  inline PlayerAnimation() : PlayerAnimation(nullptr) {}
  ~PlayerAnimation() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PlayerAnimation(
      ::google::protobuf::internal::ConstantInitialized);

  inline PlayerAnimation(const PlayerAnimation& from) : PlayerAnimation(nullptr, from) {}
  inline PlayerAnimation(PlayerAnimation&& from) noexcept
      : PlayerAnimation(nullptr, std::move(from)) {}
  inline PlayerAnimation& operator=(const PlayerAnimation& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerAnimation& operator=(PlayerAnimation&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerAnimation& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerAnimation* internal_default_instance() {
    return reinterpret_cast<const PlayerAnimation*>(
        &_PlayerAnimation_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 17;
  friend void swap(PlayerAnimation& a, PlayerAnimation& b) { a.Swap(&b); }
  inline void Swap(PlayerAnimation* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerAnimation* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerAnimation* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<PlayerAnimation>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PlayerAnimation& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PlayerAnimation& from) { PlayerAnimation::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PlayerAnimation* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "space_service.PlayerAnimation"; }

 protected:
  explicit PlayerAnimation(::google::protobuf::Arena* arena);
  PlayerAnimation(::google::protobuf::Arena* arena, const PlayerAnimation& from);
  PlayerAnimation(::google::protobuf::Arena* arena, PlayerAnimation&& from) noexcept
      : PlayerAnimation(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDataFieldNumber = 2,
    kEidFieldNumber = 1,
  };
  // .space_service.Animation data = 2;
  bool has_data() const;
  void clear_data() ;
  const ::space_service::Animation& data() const;
  PROTOBUF_NODISCARD ::space_service::Animation* release_data();
  ::space_service::Animation* mutable_data();
  void set_allocated_data(::space_service::Animation* value);
  void unsafe_arena_set_allocated_data(::space_service::Animation* value);
  ::space_service::Animation* unsafe_arena_release_data();

  private:
  const ::space_service::Animation& _internal_data() const;
  ::space_service::Animation* _internal_mutable_data();

  public:
  // int32 eid = 1;
  void clear_eid() ;
  ::int32_t eid() const;
  void set_eid(::int32_t value);

  private:
  ::int32_t _internal_eid() const;
  void _internal_set_eid(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:space_service.PlayerAnimation)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_PlayerAnimation_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const PlayerAnimation& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::space_service::Animation* data_;
    ::int32_t eid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_space_5fservice_2eproto;
};
// -------------------------------------------------------------------

class Movement final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:space_service.Movement) */ {
 public:
  inline Movement() : Movement(nullptr) {}
  ~Movement() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Movement(
      ::google::protobuf::internal::ConstantInitialized);

  inline Movement(const Movement& from) : Movement(nullptr, from) {}
  inline Movement(Movement&& from) noexcept
      : Movement(nullptr, std::move(from)) {}
  inline Movement& operator=(const Movement& from) {
    CopyFrom(from);
    return *this;
  }
  inline Movement& operator=(Movement&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Movement& default_instance() {
    return *internal_default_instance();
  }
  static inline const Movement* internal_default_instance() {
    return reinterpret_cast<const Movement*>(
        &_Movement_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(Movement& a, Movement& b) { a.Swap(&b); }
  inline void Swap(Movement* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Movement* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Movement* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<Movement>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Movement& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Movement& from) { Movement::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Movement* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "space_service.Movement"; }

 protected:
  explicit Movement(::google::protobuf::Arena* arena);
  Movement(::google::protobuf::Arena* arena, const Movement& from);
  Movement(::google::protobuf::Arena* arena, Movement&& from) noexcept
      : Movement(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPositionFieldNumber = 1,
    kRotationFieldNumber = 2,
    kVelocityFieldNumber = 3,
    kAccelerationFieldNumber = 4,
    kAngularVelocityFieldNumber = 5,
    kModeFieldNumber = 6,
    kTimestampFieldNumber = 7,
  };
  // .space_service.Vector3f position = 1;
  bool has_position() const;
  void clear_position() ;
  const ::space_service::Vector3f& position() const;
  PROTOBUF_NODISCARD ::space_service::Vector3f* release_position();
  ::space_service::Vector3f* mutable_position();
  void set_allocated_position(::space_service::Vector3f* value);
  void unsafe_arena_set_allocated_position(::space_service::Vector3f* value);
  ::space_service::Vector3f* unsafe_arena_release_position();

  private:
  const ::space_service::Vector3f& _internal_position() const;
  ::space_service::Vector3f* _internal_mutable_position();

  public:
  // .space_service.Vector3f rotation = 2;
  bool has_rotation() const;
  void clear_rotation() ;
  const ::space_service::Vector3f& rotation() const;
  PROTOBUF_NODISCARD ::space_service::Vector3f* release_rotation();
  ::space_service::Vector3f* mutable_rotation();
  void set_allocated_rotation(::space_service::Vector3f* value);
  void unsafe_arena_set_allocated_rotation(::space_service::Vector3f* value);
  ::space_service::Vector3f* unsafe_arena_release_rotation();

  private:
  const ::space_service::Vector3f& _internal_rotation() const;
  ::space_service::Vector3f* _internal_mutable_rotation();

  public:
  // optional .space_service.Vector3f velocity = 3;
  bool has_velocity() const;
  void clear_velocity() ;
  const ::space_service::Vector3f& velocity() const;
  PROTOBUF_NODISCARD ::space_service::Vector3f* release_velocity();
  ::space_service::Vector3f* mutable_velocity();
  void set_allocated_velocity(::space_service::Vector3f* value);
  void unsafe_arena_set_allocated_velocity(::space_service::Vector3f* value);
  ::space_service::Vector3f* unsafe_arena_release_velocity();

  private:
  const ::space_service::Vector3f& _internal_velocity() const;
  ::space_service::Vector3f* _internal_mutable_velocity();

  public:
  // optional .space_service.Vector3f acceleration = 4;
  bool has_acceleration() const;
  void clear_acceleration() ;
  const ::space_service::Vector3f& acceleration() const;
  PROTOBUF_NODISCARD ::space_service::Vector3f* release_acceleration();
  ::space_service::Vector3f* mutable_acceleration();
  void set_allocated_acceleration(::space_service::Vector3f* value);
  void unsafe_arena_set_allocated_acceleration(::space_service::Vector3f* value);
  ::space_service::Vector3f* unsafe_arena_release_acceleration();

  private:
  const ::space_service::Vector3f& _internal_acceleration() const;
  ::space_service::Vector3f* _internal_mutable_acceleration();

  public:
  // optional .space_service.Vector3f angular_velocity = 5;
  bool has_angular_velocity() const;
  void clear_angular_velocity() ;
  const ::space_service::Vector3f& angular_velocity() const;
  PROTOBUF_NODISCARD ::space_service::Vector3f* release_angular_velocity();
  ::space_service::Vector3f* mutable_angular_velocity();
  void set_allocated_angular_velocity(::space_service::Vector3f* value);
  void unsafe_arena_set_allocated_angular_velocity(::space_service::Vector3f* value);
  ::space_service::Vector3f* unsafe_arena_release_angular_velocity();

  private:
  const ::space_service::Vector3f& _internal_angular_velocity() const;
  ::space_service::Vector3f* _internal_mutable_angular_velocity();

  public:
  // int32 mode = 6;
  void clear_mode() ;
  ::int32_t mode() const;
  void set_mode(::int32_t value);

  private:
  ::int32_t _internal_mode() const;
  void _internal_set_mode(::int32_t value);

  public:
  // float timestamp = 7;
  void clear_timestamp() ;
  float timestamp() const;
  void set_timestamp(float value);

  private:
  float _internal_timestamp() const;
  void _internal_set_timestamp(float value);

  public:
  // @@protoc_insertion_point(class_scope:space_service.Movement)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 5,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Movement_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Movement& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::space_service::Vector3f* position_;
    ::space_service::Vector3f* rotation_;
    ::space_service::Vector3f* velocity_;
    ::space_service::Vector3f* acceleration_;
    ::space_service::Vector3f* angular_velocity_;
    ::int32_t mode_;
    float timestamp_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_space_5fservice_2eproto;
};
// -------------------------------------------------------------------

class JoinReply final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:space_service.JoinReply) */ {
 public:
  inline JoinReply() : JoinReply(nullptr) {}
  ~JoinReply() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR JoinReply(
      ::google::protobuf::internal::ConstantInitialized);

  inline JoinReply(const JoinReply& from) : JoinReply(nullptr, from) {}
  inline JoinReply(JoinReply&& from) noexcept
      : JoinReply(nullptr, std::move(from)) {}
  inline JoinReply& operator=(const JoinReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline JoinReply& operator=(JoinReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const JoinReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const JoinReply* internal_default_instance() {
    return reinterpret_cast<const JoinReply*>(
        &_JoinReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(JoinReply& a, JoinReply& b) { a.Swap(&b); }
  inline void Swap(JoinReply* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JoinReply* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  JoinReply* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<JoinReply>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const JoinReply& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const JoinReply& from) { JoinReply::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(JoinReply* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "space_service.JoinReply"; }

 protected:
  explicit JoinReply(::google::protobuf::Arena* arena);
  JoinReply(::google::protobuf::Arena* arena, const JoinReply& from);
  JoinReply(::google::protobuf::Arena* arena, JoinReply&& from) noexcept
      : JoinReply(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPositionFieldNumber = 2,
    kResultFieldNumber = 1,
  };
  // optional .space_service.Vector3f position = 2;
  bool has_position() const;
  void clear_position() ;
  const ::space_service::Vector3f& position() const;
  PROTOBUF_NODISCARD ::space_service::Vector3f* release_position();
  ::space_service::Vector3f* mutable_position();
  void set_allocated_position(::space_service::Vector3f* value);
  void unsafe_arena_set_allocated_position(::space_service::Vector3f* value);
  ::space_service::Vector3f* unsafe_arena_release_position();

  private:
  const ::space_service::Vector3f& _internal_position() const;
  ::space_service::Vector3f* _internal_mutable_position();

  public:
  // int32 result = 1;
  void clear_result() ;
  ::int32_t result() const;
  void set_result(::int32_t value);

  private:
  ::int32_t _internal_result() const;
  void _internal_set_result(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:space_service.JoinReply)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_JoinReply_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const JoinReply& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::space_service::Vector3f* position_;
    ::int32_t result_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_space_5fservice_2eproto;
};
// -------------------------------------------------------------------

class AoiUpdates final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:space_service.AoiUpdates) */ {
 public:
  inline AoiUpdates() : AoiUpdates(nullptr) {}
  ~AoiUpdates() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AoiUpdates(
      ::google::protobuf::internal::ConstantInitialized);

  inline AoiUpdates(const AoiUpdates& from) : AoiUpdates(nullptr, from) {}
  inline AoiUpdates(AoiUpdates&& from) noexcept
      : AoiUpdates(nullptr, std::move(from)) {}
  inline AoiUpdates& operator=(const AoiUpdates& from) {
    CopyFrom(from);
    return *this;
  }
  inline AoiUpdates& operator=(AoiUpdates&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AoiUpdates& default_instance() {
    return *internal_default_instance();
  }
  static inline const AoiUpdates* internal_default_instance() {
    return reinterpret_cast<const AoiUpdates*>(
        &_AoiUpdates_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 11;
  friend void swap(AoiUpdates& a, AoiUpdates& b) { a.Swap(&b); }
  inline void Swap(AoiUpdates* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AoiUpdates* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AoiUpdates* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<AoiUpdates>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AoiUpdates& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AoiUpdates& from) { AoiUpdates::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AoiUpdates* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "space_service.AoiUpdates"; }

 protected:
  explicit AoiUpdates(::google::protobuf::Arena* arena);
  AoiUpdates(::google::protobuf::Arena* arena, const AoiUpdates& from);
  AoiUpdates(::google::protobuf::Arena* arena, AoiUpdates&& from) noexcept
      : AoiUpdates(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDatasFieldNumber = 1,
  };
  // repeated .space_service.AoiUpdate datas = 1;
  int datas_size() const;
  private:
  int _internal_datas_size() const;

  public:
  void clear_datas() ;
  ::space_service::AoiUpdate* mutable_datas(int index);
  ::google::protobuf::RepeatedPtrField<::space_service::AoiUpdate>* mutable_datas();

  private:
  const ::google::protobuf::RepeatedPtrField<::space_service::AoiUpdate>& _internal_datas() const;
  ::google::protobuf::RepeatedPtrField<::space_service::AoiUpdate>* _internal_mutable_datas();
  public:
  const ::space_service::AoiUpdate& datas(int index) const;
  ::space_service::AoiUpdate* add_datas();
  const ::google::protobuf::RepeatedPtrField<::space_service::AoiUpdate>& datas() const;
  // @@protoc_insertion_point(class_scope:space_service.AoiUpdates)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_AoiUpdates_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const AoiUpdates& from_msg);
    ::google::protobuf::RepeatedPtrField< ::space_service::AoiUpdate > datas_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_space_5fservice_2eproto;
};
// -------------------------------------------------------------------

class AoiEntity final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:space_service.AoiEntity) */ {
 public:
  inline AoiEntity() : AoiEntity(nullptr) {}
  ~AoiEntity() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AoiEntity(
      ::google::protobuf::internal::ConstantInitialized);

  inline AoiEntity(const AoiEntity& from) : AoiEntity(nullptr, from) {}
  inline AoiEntity(AoiEntity&& from) noexcept
      : AoiEntity(nullptr, std::move(from)) {}
  inline AoiEntity& operator=(const AoiEntity& from) {
    CopyFrom(from);
    return *this;
  }
  inline AoiEntity& operator=(AoiEntity&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AoiEntity& default_instance() {
    return *internal_default_instance();
  }
  static inline const AoiEntity* internal_default_instance() {
    return reinterpret_cast<const AoiEntity*>(
        &_AoiEntity_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(AoiEntity& a, AoiEntity& b) { a.Swap(&b); }
  inline void Swap(AoiEntity* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AoiEntity* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AoiEntity* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<AoiEntity>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AoiEntity& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AoiEntity& from) { AoiEntity::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AoiEntity* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "space_service.AoiEntity"; }

 protected:
  explicit AoiEntity(::google::protobuf::Arena* arena);
  AoiEntity(::google::protobuf::Arena* arena, const AoiEntity& from);
  AoiEntity(::google::protobuf::Arena* arena, AoiEntity&& from) noexcept
      : AoiEntity(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEntityTypeFieldNumber = 1,
    kDataFieldNumber = 2,
    kPositionFieldNumber = 3,
    kRotationFieldNumber = 4,
  };
  // string entity_type = 1;
  void clear_entity_type() ;
  const std::string& entity_type() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_entity_type(Arg_&& arg, Args_... args);
  std::string* mutable_entity_type();
  PROTOBUF_NODISCARD std::string* release_entity_type();
  void set_allocated_entity_type(std::string* value);

  private:
  const std::string& _internal_entity_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_entity_type(
      const std::string& value);
  std::string* _internal_mutable_entity_type();

  public:
  // bytes data = 2;
  void clear_data() ;
  const std::string& data() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_data(Arg_&& arg, Args_... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* value);

  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(
      const std::string& value);
  std::string* _internal_mutable_data();

  public:
  // .space_service.Vector3f position = 3;
  bool has_position() const;
  void clear_position() ;
  const ::space_service::Vector3f& position() const;
  PROTOBUF_NODISCARD ::space_service::Vector3f* release_position();
  ::space_service::Vector3f* mutable_position();
  void set_allocated_position(::space_service::Vector3f* value);
  void unsafe_arena_set_allocated_position(::space_service::Vector3f* value);
  ::space_service::Vector3f* unsafe_arena_release_position();

  private:
  const ::space_service::Vector3f& _internal_position() const;
  ::space_service::Vector3f* _internal_mutable_position();

  public:
  // .space_service.Vector3f rotation = 4;
  bool has_rotation() const;
  void clear_rotation() ;
  const ::space_service::Vector3f& rotation() const;
  PROTOBUF_NODISCARD ::space_service::Vector3f* release_rotation();
  ::space_service::Vector3f* mutable_rotation();
  void set_allocated_rotation(::space_service::Vector3f* value);
  void unsafe_arena_set_allocated_rotation(::space_service::Vector3f* value);
  ::space_service::Vector3f* unsafe_arena_release_rotation();

  private:
  const ::space_service::Vector3f& _internal_rotation() const;
  ::space_service::Vector3f* _internal_mutable_rotation();

  public:
  // @@protoc_insertion_point(class_scope:space_service.AoiEntity)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 2,
      43, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_AoiEntity_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const AoiEntity& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr entity_type_;
    ::google::protobuf::internal::ArenaStringPtr data_;
    ::space_service::Vector3f* position_;
    ::space_service::Vector3f* rotation_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_space_5fservice_2eproto;
};
// -------------------------------------------------------------------

class EntitiesEnterSight final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:space_service.EntitiesEnterSight) */ {
 public:
  inline EntitiesEnterSight() : EntitiesEnterSight(nullptr) {}
  ~EntitiesEnterSight() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR EntitiesEnterSight(
      ::google::protobuf::internal::ConstantInitialized);

  inline EntitiesEnterSight(const EntitiesEnterSight& from) : EntitiesEnterSight(nullptr, from) {}
  inline EntitiesEnterSight(EntitiesEnterSight&& from) noexcept
      : EntitiesEnterSight(nullptr, std::move(from)) {}
  inline EntitiesEnterSight& operator=(const EntitiesEnterSight& from) {
    CopyFrom(from);
    return *this;
  }
  inline EntitiesEnterSight& operator=(EntitiesEnterSight&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EntitiesEnterSight& default_instance() {
    return *internal_default_instance();
  }
  static inline const EntitiesEnterSight* internal_default_instance() {
    return reinterpret_cast<const EntitiesEnterSight*>(
        &_EntitiesEnterSight_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(EntitiesEnterSight& a, EntitiesEnterSight& b) { a.Swap(&b); }
  inline void Swap(EntitiesEnterSight* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EntitiesEnterSight* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EntitiesEnterSight* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<EntitiesEnterSight>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EntitiesEnterSight& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const EntitiesEnterSight& from) { EntitiesEnterSight::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(EntitiesEnterSight* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "space_service.EntitiesEnterSight"; }

 protected:
  explicit EntitiesEnterSight(::google::protobuf::Arena* arena);
  EntitiesEnterSight(::google::protobuf::Arena* arena, const EntitiesEnterSight& from);
  EntitiesEnterSight(::google::protobuf::Arena* arena, EntitiesEnterSight&& from) noexcept
      : EntitiesEnterSight(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEntitiesFieldNumber = 1,
  };
  // repeated .space_service.AoiEntity entities = 1;
  int entities_size() const;
  private:
  int _internal_entities_size() const;

  public:
  void clear_entities() ;
  ::space_service::AoiEntity* mutable_entities(int index);
  ::google::protobuf::RepeatedPtrField<::space_service::AoiEntity>* mutable_entities();

  private:
  const ::google::protobuf::RepeatedPtrField<::space_service::AoiEntity>& _internal_entities() const;
  ::google::protobuf::RepeatedPtrField<::space_service::AoiEntity>* _internal_mutable_entities();
  public:
  const ::space_service::AoiEntity& entities(int index) const;
  ::space_service::AoiEntity* add_entities();
  const ::google::protobuf::RepeatedPtrField<::space_service::AoiEntity>& entities() const;
  // @@protoc_insertion_point(class_scope:space_service.EntitiesEnterSight)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_EntitiesEnterSight_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const EntitiesEnterSight& from_msg);
    ::google::protobuf::RepeatedPtrField< ::space_service::AoiEntity > entities_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_space_5fservice_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Vector3f

// float x = 1;
inline void Vector3f::clear_x() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.x_ = 0;
}
inline float Vector3f::x() const {
  // @@protoc_insertion_point(field_get:space_service.Vector3f.x)
  return _internal_x();
}
inline void Vector3f::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:space_service.Vector3f.x)
}
inline float Vector3f::_internal_x() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.x_;
}
inline void Vector3f::_internal_set_x(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.x_ = value;
}

// float y = 2;
inline void Vector3f::clear_y() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.y_ = 0;
}
inline float Vector3f::y() const {
  // @@protoc_insertion_point(field_get:space_service.Vector3f.y)
  return _internal_y();
}
inline void Vector3f::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:space_service.Vector3f.y)
}
inline float Vector3f::_internal_y() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.y_;
}
inline void Vector3f::_internal_set_y(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.y_ = value;
}

// float z = 3;
inline void Vector3f::clear_z() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.z_ = 0;
}
inline float Vector3f::z() const {
  // @@protoc_insertion_point(field_get:space_service.Vector3f.z)
  return _internal_z();
}
inline void Vector3f::set_z(float value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:space_service.Vector3f.z)
}
inline float Vector3f::_internal_z() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.z_;
}
inline void Vector3f::_internal_set_z(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.z_ = value;
}

// -------------------------------------------------------------------

// Movement

// .space_service.Vector3f position = 1;
inline bool Movement::has_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.position_ != nullptr);
  return value;
}
inline void Movement::clear_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.position_ != nullptr) _impl_.position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::space_service::Vector3f& Movement::_internal_position() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::space_service::Vector3f* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::space_service::Vector3f&>(::space_service::_Vector3f_default_instance_);
}
inline const ::space_service::Vector3f& Movement::position() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:space_service.Movement.position)
  return _internal_position();
}
inline void Movement::unsafe_arena_set_allocated_position(::space_service::Vector3f* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = reinterpret_cast<::space_service::Vector3f*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:space_service.Movement.position)
}
inline ::space_service::Vector3f* Movement::release_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::space_service::Vector3f* released = _impl_.position_;
  _impl_.position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::space_service::Vector3f* Movement::unsafe_arena_release_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:space_service.Movement.position)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::space_service::Vector3f* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::space_service::Vector3f* Movement::_internal_mutable_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.position_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::space_service::Vector3f>(GetArena());
    _impl_.position_ = reinterpret_cast<::space_service::Vector3f*>(p);
  }
  return _impl_.position_;
}
inline ::space_service::Vector3f* Movement::mutable_position() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::space_service::Vector3f* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:space_service.Movement.position)
  return _msg;
}
inline void Movement::set_allocated_position(::space_service::Vector3f* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.position_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.position_ = reinterpret_cast<::space_service::Vector3f*>(value);
  // @@protoc_insertion_point(field_set_allocated:space_service.Movement.position)
}

// .space_service.Vector3f rotation = 2;
inline bool Movement::has_rotation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.rotation_ != nullptr);
  return value;
}
inline void Movement::clear_rotation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.rotation_ != nullptr) _impl_.rotation_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::space_service::Vector3f& Movement::_internal_rotation() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::space_service::Vector3f* p = _impl_.rotation_;
  return p != nullptr ? *p : reinterpret_cast<const ::space_service::Vector3f&>(::space_service::_Vector3f_default_instance_);
}
inline const ::space_service::Vector3f& Movement::rotation() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:space_service.Movement.rotation)
  return _internal_rotation();
}
inline void Movement::unsafe_arena_set_allocated_rotation(::space_service::Vector3f* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.rotation_);
  }
  _impl_.rotation_ = reinterpret_cast<::space_service::Vector3f*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:space_service.Movement.rotation)
}
inline ::space_service::Vector3f* Movement::release_rotation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::space_service::Vector3f* released = _impl_.rotation_;
  _impl_.rotation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::space_service::Vector3f* Movement::unsafe_arena_release_rotation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:space_service.Movement.rotation)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::space_service::Vector3f* temp = _impl_.rotation_;
  _impl_.rotation_ = nullptr;
  return temp;
}
inline ::space_service::Vector3f* Movement::_internal_mutable_rotation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.rotation_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::space_service::Vector3f>(GetArena());
    _impl_.rotation_ = reinterpret_cast<::space_service::Vector3f*>(p);
  }
  return _impl_.rotation_;
}
inline ::space_service::Vector3f* Movement::mutable_rotation() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::space_service::Vector3f* _msg = _internal_mutable_rotation();
  // @@protoc_insertion_point(field_mutable:space_service.Movement.rotation)
  return _msg;
}
inline void Movement::set_allocated_rotation(::space_service::Vector3f* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.rotation_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.rotation_ = reinterpret_cast<::space_service::Vector3f*>(value);
  // @@protoc_insertion_point(field_set_allocated:space_service.Movement.rotation)
}

// optional .space_service.Vector3f velocity = 3;
inline bool Movement::has_velocity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.velocity_ != nullptr);
  return value;
}
inline void Movement::clear_velocity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.velocity_ != nullptr) _impl_.velocity_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::space_service::Vector3f& Movement::_internal_velocity() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::space_service::Vector3f* p = _impl_.velocity_;
  return p != nullptr ? *p : reinterpret_cast<const ::space_service::Vector3f&>(::space_service::_Vector3f_default_instance_);
}
inline const ::space_service::Vector3f& Movement::velocity() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:space_service.Movement.velocity)
  return _internal_velocity();
}
inline void Movement::unsafe_arena_set_allocated_velocity(::space_service::Vector3f* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.velocity_);
  }
  _impl_.velocity_ = reinterpret_cast<::space_service::Vector3f*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:space_service.Movement.velocity)
}
inline ::space_service::Vector3f* Movement::release_velocity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::space_service::Vector3f* released = _impl_.velocity_;
  _impl_.velocity_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::space_service::Vector3f* Movement::unsafe_arena_release_velocity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:space_service.Movement.velocity)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::space_service::Vector3f* temp = _impl_.velocity_;
  _impl_.velocity_ = nullptr;
  return temp;
}
inline ::space_service::Vector3f* Movement::_internal_mutable_velocity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.velocity_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::space_service::Vector3f>(GetArena());
    _impl_.velocity_ = reinterpret_cast<::space_service::Vector3f*>(p);
  }
  return _impl_.velocity_;
}
inline ::space_service::Vector3f* Movement::mutable_velocity() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::space_service::Vector3f* _msg = _internal_mutable_velocity();
  // @@protoc_insertion_point(field_mutable:space_service.Movement.velocity)
  return _msg;
}
inline void Movement::set_allocated_velocity(::space_service::Vector3f* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.velocity_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.velocity_ = reinterpret_cast<::space_service::Vector3f*>(value);
  // @@protoc_insertion_point(field_set_allocated:space_service.Movement.velocity)
}

// optional .space_service.Vector3f acceleration = 4;
inline bool Movement::has_acceleration() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.acceleration_ != nullptr);
  return value;
}
inline void Movement::clear_acceleration() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.acceleration_ != nullptr) _impl_.acceleration_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::space_service::Vector3f& Movement::_internal_acceleration() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::space_service::Vector3f* p = _impl_.acceleration_;
  return p != nullptr ? *p : reinterpret_cast<const ::space_service::Vector3f&>(::space_service::_Vector3f_default_instance_);
}
inline const ::space_service::Vector3f& Movement::acceleration() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:space_service.Movement.acceleration)
  return _internal_acceleration();
}
inline void Movement::unsafe_arena_set_allocated_acceleration(::space_service::Vector3f* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.acceleration_);
  }
  _impl_.acceleration_ = reinterpret_cast<::space_service::Vector3f*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:space_service.Movement.acceleration)
}
inline ::space_service::Vector3f* Movement::release_acceleration() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::space_service::Vector3f* released = _impl_.acceleration_;
  _impl_.acceleration_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::space_service::Vector3f* Movement::unsafe_arena_release_acceleration() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:space_service.Movement.acceleration)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::space_service::Vector3f* temp = _impl_.acceleration_;
  _impl_.acceleration_ = nullptr;
  return temp;
}
inline ::space_service::Vector3f* Movement::_internal_mutable_acceleration() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.acceleration_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::space_service::Vector3f>(GetArena());
    _impl_.acceleration_ = reinterpret_cast<::space_service::Vector3f*>(p);
  }
  return _impl_.acceleration_;
}
inline ::space_service::Vector3f* Movement::mutable_acceleration() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000008u;
  ::space_service::Vector3f* _msg = _internal_mutable_acceleration();
  // @@protoc_insertion_point(field_mutable:space_service.Movement.acceleration)
  return _msg;
}
inline void Movement::set_allocated_acceleration(::space_service::Vector3f* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.acceleration_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.acceleration_ = reinterpret_cast<::space_service::Vector3f*>(value);
  // @@protoc_insertion_point(field_set_allocated:space_service.Movement.acceleration)
}

// optional .space_service.Vector3f angular_velocity = 5;
inline bool Movement::has_angular_velocity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.angular_velocity_ != nullptr);
  return value;
}
inline void Movement::clear_angular_velocity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.angular_velocity_ != nullptr) _impl_.angular_velocity_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::space_service::Vector3f& Movement::_internal_angular_velocity() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::space_service::Vector3f* p = _impl_.angular_velocity_;
  return p != nullptr ? *p : reinterpret_cast<const ::space_service::Vector3f&>(::space_service::_Vector3f_default_instance_);
}
inline const ::space_service::Vector3f& Movement::angular_velocity() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:space_service.Movement.angular_velocity)
  return _internal_angular_velocity();
}
inline void Movement::unsafe_arena_set_allocated_angular_velocity(::space_service::Vector3f* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.angular_velocity_);
  }
  _impl_.angular_velocity_ = reinterpret_cast<::space_service::Vector3f*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:space_service.Movement.angular_velocity)
}
inline ::space_service::Vector3f* Movement::release_angular_velocity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::space_service::Vector3f* released = _impl_.angular_velocity_;
  _impl_.angular_velocity_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::space_service::Vector3f* Movement::unsafe_arena_release_angular_velocity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:space_service.Movement.angular_velocity)

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::space_service::Vector3f* temp = _impl_.angular_velocity_;
  _impl_.angular_velocity_ = nullptr;
  return temp;
}
inline ::space_service::Vector3f* Movement::_internal_mutable_angular_velocity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.angular_velocity_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::space_service::Vector3f>(GetArena());
    _impl_.angular_velocity_ = reinterpret_cast<::space_service::Vector3f*>(p);
  }
  return _impl_.angular_velocity_;
}
inline ::space_service::Vector3f* Movement::mutable_angular_velocity() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000010u;
  ::space_service::Vector3f* _msg = _internal_mutable_angular_velocity();
  // @@protoc_insertion_point(field_mutable:space_service.Movement.angular_velocity)
  return _msg;
}
inline void Movement::set_allocated_angular_velocity(::space_service::Vector3f* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.angular_velocity_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }

  _impl_.angular_velocity_ = reinterpret_cast<::space_service::Vector3f*>(value);
  // @@protoc_insertion_point(field_set_allocated:space_service.Movement.angular_velocity)
}

// int32 mode = 6;
inline void Movement::clear_mode() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.mode_ = 0;
}
inline ::int32_t Movement::mode() const {
  // @@protoc_insertion_point(field_get:space_service.Movement.mode)
  return _internal_mode();
}
inline void Movement::set_mode(::int32_t value) {
  _internal_set_mode(value);
  // @@protoc_insertion_point(field_set:space_service.Movement.mode)
}
inline ::int32_t Movement::_internal_mode() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.mode_;
}
inline void Movement::_internal_set_mode(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.mode_ = value;
}

// float timestamp = 7;
inline void Movement::clear_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timestamp_ = 0;
}
inline float Movement::timestamp() const {
  // @@protoc_insertion_point(field_get:space_service.Movement.timestamp)
  return _internal_timestamp();
}
inline void Movement::set_timestamp(float value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:space_service.Movement.timestamp)
}
inline float Movement::_internal_timestamp() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.timestamp_;
}
inline void Movement::_internal_set_timestamp(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timestamp_ = value;
}

// -------------------------------------------------------------------

// LoginRequest

// string username = 1;
inline void LoginRequest::clear_username() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.username_.ClearToEmpty();
}
inline const std::string& LoginRequest::username() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:space_service.LoginRequest.username)
  return _internal_username();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void LoginRequest::set_username(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.username_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:space_service.LoginRequest.username)
}
inline std::string* LoginRequest::mutable_username() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:space_service.LoginRequest.username)
  return _s;
}
inline const std::string& LoginRequest::_internal_username() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.username_.Get();
}
inline void LoginRequest::_internal_set_username(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.username_.Set(value, GetArena());
}
inline std::string* LoginRequest::_internal_mutable_username() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.username_.Mutable( GetArena());
}
inline std::string* LoginRequest::release_username() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:space_service.LoginRequest.username)
  return _impl_.username_.Release();
}
inline void LoginRequest::set_allocated_username(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.username_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.username_.IsDefault()) {
          _impl_.username_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:space_service.LoginRequest.username)
}

// -------------------------------------------------------------------

// LoginReply

// int32 result = 1;
inline void LoginReply::clear_result() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.result_ = 0;
}
inline ::int32_t LoginReply::result() const {
  // @@protoc_insertion_point(field_get:space_service.LoginReply.result)
  return _internal_result();
}
inline void LoginReply::set_result(::int32_t value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:space_service.LoginReply.result)
}
inline ::int32_t LoginReply::_internal_result() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.result_;
}
inline void LoginReply::_internal_set_result(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.result_ = value;
}

// int32 eid = 2;
inline void LoginReply::clear_eid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.eid_ = 0;
}
inline ::int32_t LoginReply::eid() const {
  // @@protoc_insertion_point(field_get:space_service.LoginReply.eid)
  return _internal_eid();
}
inline void LoginReply::set_eid(::int32_t value) {
  _internal_set_eid(value);
  // @@protoc_insertion_point(field_set:space_service.LoginReply.eid)
}
inline ::int32_t LoginReply::_internal_eid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.eid_;
}
inline void LoginReply::_internal_set_eid(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.eid_ = value;
}

// -------------------------------------------------------------------

// JoinReply

// int32 result = 1;
inline void JoinReply::clear_result() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.result_ = 0;
}
inline ::int32_t JoinReply::result() const {
  // @@protoc_insertion_point(field_get:space_service.JoinReply.result)
  return _internal_result();
}
inline void JoinReply::set_result(::int32_t value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:space_service.JoinReply.result)
}
inline ::int32_t JoinReply::_internal_result() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.result_;
}
inline void JoinReply::_internal_set_result(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.result_ = value;
}

// optional .space_service.Vector3f position = 2;
inline bool JoinReply::has_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.position_ != nullptr);
  return value;
}
inline void JoinReply::clear_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.position_ != nullptr) _impl_.position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::space_service::Vector3f& JoinReply::_internal_position() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::space_service::Vector3f* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::space_service::Vector3f&>(::space_service::_Vector3f_default_instance_);
}
inline const ::space_service::Vector3f& JoinReply::position() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:space_service.JoinReply.position)
  return _internal_position();
}
inline void JoinReply::unsafe_arena_set_allocated_position(::space_service::Vector3f* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = reinterpret_cast<::space_service::Vector3f*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:space_service.JoinReply.position)
}
inline ::space_service::Vector3f* JoinReply::release_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::space_service::Vector3f* released = _impl_.position_;
  _impl_.position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::space_service::Vector3f* JoinReply::unsafe_arena_release_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:space_service.JoinReply.position)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::space_service::Vector3f* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::space_service::Vector3f* JoinReply::_internal_mutable_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.position_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::space_service::Vector3f>(GetArena());
    _impl_.position_ = reinterpret_cast<::space_service::Vector3f*>(p);
  }
  return _impl_.position_;
}
inline ::space_service::Vector3f* JoinReply::mutable_position() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::space_service::Vector3f* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:space_service.JoinReply.position)
  return _msg;
}
inline void JoinReply::set_allocated_position(::space_service::Vector3f* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.position_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.position_ = reinterpret_cast<::space_service::Vector3f*>(value);
  // @@protoc_insertion_point(field_set_allocated:space_service.JoinReply.position)
}

// -------------------------------------------------------------------

// PlayerInfo

// int32 eid = 1;
inline void PlayerInfo::clear_eid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.eid_ = 0;
}
inline ::int32_t PlayerInfo::eid() const {
  // @@protoc_insertion_point(field_get:space_service.PlayerInfo.eid)
  return _internal_eid();
}
inline void PlayerInfo::set_eid(::int32_t value) {
  _internal_set_eid(value);
  // @@protoc_insertion_point(field_set:space_service.PlayerInfo.eid)
}
inline ::int32_t PlayerInfo::_internal_eid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.eid_;
}
inline void PlayerInfo::_internal_set_eid(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.eid_ = value;
}

// bytes data = 2;
inline void PlayerInfo::clear_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.data_.ClearToEmpty();
}
inline const std::string& PlayerInfo::data() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:space_service.PlayerInfo.data)
  return _internal_data();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PlayerInfo::set_data(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.data_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:space_service.PlayerInfo.data)
}
inline std::string* PlayerInfo::mutable_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:space_service.PlayerInfo.data)
  return _s;
}
inline const std::string& PlayerInfo::_internal_data() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.data_.Get();
}
inline void PlayerInfo::_internal_set_data(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.data_.Set(value, GetArena());
}
inline std::string* PlayerInfo::_internal_mutable_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.data_.Mutable( GetArena());
}
inline std::string* PlayerInfo::release_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:space_service.PlayerInfo.data)
  return _impl_.data_.Release();
}
inline void PlayerInfo::set_allocated_data(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.data_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.data_.IsDefault()) {
          _impl_.data_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:space_service.PlayerInfo.data)
}

// -------------------------------------------------------------------

// PlayerDeltaInfo

// int32 eid = 1;
inline void PlayerDeltaInfo::clear_eid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.eid_ = 0;
}
inline ::int32_t PlayerDeltaInfo::eid() const {
  // @@protoc_insertion_point(field_get:space_service.PlayerDeltaInfo.eid)
  return _internal_eid();
}
inline void PlayerDeltaInfo::set_eid(::int32_t value) {
  _internal_set_eid(value);
  // @@protoc_insertion_point(field_set:space_service.PlayerDeltaInfo.eid)
}
inline ::int32_t PlayerDeltaInfo::_internal_eid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.eid_;
}
inline void PlayerDeltaInfo::_internal_set_eid(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.eid_ = value;
}

// bytes data = 2;
inline void PlayerDeltaInfo::clear_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.data_.ClearToEmpty();
}
inline const std::string& PlayerDeltaInfo::data() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:space_service.PlayerDeltaInfo.data)
  return _internal_data();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PlayerDeltaInfo::set_data(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.data_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:space_service.PlayerDeltaInfo.data)
}
inline std::string* PlayerDeltaInfo::mutable_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:space_service.PlayerDeltaInfo.data)
  return _s;
}
inline const std::string& PlayerDeltaInfo::_internal_data() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.data_.Get();
}
inline void PlayerDeltaInfo::_internal_set_data(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.data_.Set(value, GetArena());
}
inline std::string* PlayerDeltaInfo::_internal_mutable_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.data_.Mutable( GetArena());
}
inline std::string* PlayerDeltaInfo::release_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:space_service.PlayerDeltaInfo.data)
  return _impl_.data_.Release();
}
inline void PlayerDeltaInfo::set_allocated_data(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.data_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.data_.IsDefault()) {
          _impl_.data_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:space_service.PlayerDeltaInfo.data)
}

// -------------------------------------------------------------------

// AoiEntity

// string entity_type = 1;
inline void AoiEntity::clear_entity_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entity_type_.ClearToEmpty();
}
inline const std::string& AoiEntity::entity_type() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:space_service.AoiEntity.entity_type)
  return _internal_entity_type();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AoiEntity::set_entity_type(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entity_type_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:space_service.AoiEntity.entity_type)
}
inline std::string* AoiEntity::mutable_entity_type() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_entity_type();
  // @@protoc_insertion_point(field_mutable:space_service.AoiEntity.entity_type)
  return _s;
}
inline const std::string& AoiEntity::_internal_entity_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.entity_type_.Get();
}
inline void AoiEntity::_internal_set_entity_type(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entity_type_.Set(value, GetArena());
}
inline std::string* AoiEntity::_internal_mutable_entity_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.entity_type_.Mutable( GetArena());
}
inline std::string* AoiEntity::release_entity_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:space_service.AoiEntity.entity_type)
  return _impl_.entity_type_.Release();
}
inline void AoiEntity::set_allocated_entity_type(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entity_type_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.entity_type_.IsDefault()) {
          _impl_.entity_type_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:space_service.AoiEntity.entity_type)
}

// bytes data = 2;
inline void AoiEntity::clear_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.data_.ClearToEmpty();
}
inline const std::string& AoiEntity::data() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:space_service.AoiEntity.data)
  return _internal_data();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AoiEntity::set_data(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.data_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:space_service.AoiEntity.data)
}
inline std::string* AoiEntity::mutable_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:space_service.AoiEntity.data)
  return _s;
}
inline const std::string& AoiEntity::_internal_data() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.data_.Get();
}
inline void AoiEntity::_internal_set_data(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.data_.Set(value, GetArena());
}
inline std::string* AoiEntity::_internal_mutable_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.data_.Mutable( GetArena());
}
inline std::string* AoiEntity::release_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:space_service.AoiEntity.data)
  return _impl_.data_.Release();
}
inline void AoiEntity::set_allocated_data(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.data_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.data_.IsDefault()) {
          _impl_.data_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:space_service.AoiEntity.data)
}

// .space_service.Vector3f position = 3;
inline bool AoiEntity::has_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.position_ != nullptr);
  return value;
}
inline void AoiEntity::clear_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.position_ != nullptr) _impl_.position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::space_service::Vector3f& AoiEntity::_internal_position() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::space_service::Vector3f* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::space_service::Vector3f&>(::space_service::_Vector3f_default_instance_);
}
inline const ::space_service::Vector3f& AoiEntity::position() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:space_service.AoiEntity.position)
  return _internal_position();
}
inline void AoiEntity::unsafe_arena_set_allocated_position(::space_service::Vector3f* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = reinterpret_cast<::space_service::Vector3f*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:space_service.AoiEntity.position)
}
inline ::space_service::Vector3f* AoiEntity::release_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::space_service::Vector3f* released = _impl_.position_;
  _impl_.position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::space_service::Vector3f* AoiEntity::unsafe_arena_release_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:space_service.AoiEntity.position)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::space_service::Vector3f* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::space_service::Vector3f* AoiEntity::_internal_mutable_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.position_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::space_service::Vector3f>(GetArena());
    _impl_.position_ = reinterpret_cast<::space_service::Vector3f*>(p);
  }
  return _impl_.position_;
}
inline ::space_service::Vector3f* AoiEntity::mutable_position() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::space_service::Vector3f* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:space_service.AoiEntity.position)
  return _msg;
}
inline void AoiEntity::set_allocated_position(::space_service::Vector3f* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.position_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.position_ = reinterpret_cast<::space_service::Vector3f*>(value);
  // @@protoc_insertion_point(field_set_allocated:space_service.AoiEntity.position)
}

// .space_service.Vector3f rotation = 4;
inline bool AoiEntity::has_rotation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.rotation_ != nullptr);
  return value;
}
inline void AoiEntity::clear_rotation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.rotation_ != nullptr) _impl_.rotation_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::space_service::Vector3f& AoiEntity::_internal_rotation() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::space_service::Vector3f* p = _impl_.rotation_;
  return p != nullptr ? *p : reinterpret_cast<const ::space_service::Vector3f&>(::space_service::_Vector3f_default_instance_);
}
inline const ::space_service::Vector3f& AoiEntity::rotation() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:space_service.AoiEntity.rotation)
  return _internal_rotation();
}
inline void AoiEntity::unsafe_arena_set_allocated_rotation(::space_service::Vector3f* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.rotation_);
  }
  _impl_.rotation_ = reinterpret_cast<::space_service::Vector3f*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:space_service.AoiEntity.rotation)
}
inline ::space_service::Vector3f* AoiEntity::release_rotation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::space_service::Vector3f* released = _impl_.rotation_;
  _impl_.rotation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::space_service::Vector3f* AoiEntity::unsafe_arena_release_rotation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:space_service.AoiEntity.rotation)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::space_service::Vector3f* temp = _impl_.rotation_;
  _impl_.rotation_ = nullptr;
  return temp;
}
inline ::space_service::Vector3f* AoiEntity::_internal_mutable_rotation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.rotation_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::space_service::Vector3f>(GetArena());
    _impl_.rotation_ = reinterpret_cast<::space_service::Vector3f*>(p);
  }
  return _impl_.rotation_;
}
inline ::space_service::Vector3f* AoiEntity::mutable_rotation() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::space_service::Vector3f* _msg = _internal_mutable_rotation();
  // @@protoc_insertion_point(field_mutable:space_service.AoiEntity.rotation)
  return _msg;
}
inline void AoiEntity::set_allocated_rotation(::space_service::Vector3f* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.rotation_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.rotation_ = reinterpret_cast<::space_service::Vector3f*>(value);
  // @@protoc_insertion_point(field_set_allocated:space_service.AoiEntity.rotation)
}

// -------------------------------------------------------------------

// EntitiesEnterSight

// repeated .space_service.AoiEntity entities = 1;
inline int EntitiesEnterSight::_internal_entities_size() const {
  return _internal_entities().size();
}
inline int EntitiesEnterSight::entities_size() const {
  return _internal_entities_size();
}
inline void EntitiesEnterSight::clear_entities() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entities_.Clear();
}
inline ::space_service::AoiEntity* EntitiesEnterSight::mutable_entities(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:space_service.EntitiesEnterSight.entities)
  return _internal_mutable_entities()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::space_service::AoiEntity>* EntitiesEnterSight::mutable_entities()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:space_service.EntitiesEnterSight.entities)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_entities();
}
inline const ::space_service::AoiEntity& EntitiesEnterSight::entities(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:space_service.EntitiesEnterSight.entities)
  return _internal_entities().Get(index);
}
inline ::space_service::AoiEntity* EntitiesEnterSight::add_entities() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::space_service::AoiEntity* _add = _internal_mutable_entities()->Add();
  // @@protoc_insertion_point(field_add:space_service.EntitiesEnterSight.entities)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::space_service::AoiEntity>& EntitiesEnterSight::entities() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:space_service.EntitiesEnterSight.entities)
  return _internal_entities();
}
inline const ::google::protobuf::RepeatedPtrField<::space_service::AoiEntity>&
EntitiesEnterSight::_internal_entities() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.entities_;
}
inline ::google::protobuf::RepeatedPtrField<::space_service::AoiEntity>*
EntitiesEnterSight::_internal_mutable_entities() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.entities_;
}

// -------------------------------------------------------------------

// EntitiesLeaveSight

// repeated int32 entities = 1;
inline int EntitiesLeaveSight::_internal_entities_size() const {
  return _internal_entities().size();
}
inline int EntitiesLeaveSight::entities_size() const {
  return _internal_entities_size();
}
inline void EntitiesLeaveSight::clear_entities() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entities_.Clear();
}
inline ::int32_t EntitiesLeaveSight::entities(int index) const {
  // @@protoc_insertion_point(field_get:space_service.EntitiesLeaveSight.entities)
  return _internal_entities().Get(index);
}
inline void EntitiesLeaveSight::set_entities(int index, ::int32_t value) {
  _internal_mutable_entities()->Set(index, value);
  // @@protoc_insertion_point(field_set:space_service.EntitiesLeaveSight.entities)
}
inline void EntitiesLeaveSight::add_entities(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_entities()->Add(value);
  // @@protoc_insertion_point(field_add:space_service.EntitiesLeaveSight.entities)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& EntitiesLeaveSight::entities() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:space_service.EntitiesLeaveSight.entities)
  return _internal_entities();
}
inline ::google::protobuf::RepeatedField<::int32_t>* EntitiesLeaveSight::mutable_entities()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:space_service.EntitiesLeaveSight.entities)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_entities();
}
inline const ::google::protobuf::RepeatedField<::int32_t>&
EntitiesLeaveSight::_internal_entities() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.entities_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* EntitiesLeaveSight::_internal_mutable_entities() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.entities_;
}

// -------------------------------------------------------------------

// AoiUpdate

// int32 eid = 1;
inline void AoiUpdate::clear_eid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.eid_ = 0;
}
inline ::int32_t AoiUpdate::eid() const {
  // @@protoc_insertion_point(field_get:space_service.AoiUpdate.eid)
  return _internal_eid();
}
inline void AoiUpdate::set_eid(::int32_t value) {
  _internal_set_eid(value);
  // @@protoc_insertion_point(field_set:space_service.AoiUpdate.eid)
}
inline ::int32_t AoiUpdate::_internal_eid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.eid_;
}
inline void AoiUpdate::_internal_set_eid(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.eid_ = value;
}

// optional bytes data = 2;
inline bool AoiUpdate::has_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AoiUpdate::clear_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.data_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AoiUpdate::data() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:space_service.AoiUpdate.data)
  return _internal_data();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AoiUpdate::set_data(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.data_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:space_service.AoiUpdate.data)
}
inline std::string* AoiUpdate::mutable_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:space_service.AoiUpdate.data)
  return _s;
}
inline const std::string& AoiUpdate::_internal_data() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.data_.Get();
}
inline void AoiUpdate::_internal_set_data(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.data_.Set(value, GetArena());
}
inline std::string* AoiUpdate::_internal_mutable_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.data_.Mutable( GetArena());
}
inline std::string* AoiUpdate::release_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:space_service.AoiUpdate.data)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.data_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.data_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void AoiUpdate::set_allocated_data(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.data_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.data_.IsDefault()) {
          _impl_.data_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:space_service.AoiUpdate.data)
}

// -------------------------------------------------------------------

// AoiUpdates

// repeated .space_service.AoiUpdate datas = 1;
inline int AoiUpdates::_internal_datas_size() const {
  return _internal_datas().size();
}
inline int AoiUpdates::datas_size() const {
  return _internal_datas_size();
}
inline void AoiUpdates::clear_datas() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.datas_.Clear();
}
inline ::space_service::AoiUpdate* AoiUpdates::mutable_datas(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:space_service.AoiUpdates.datas)
  return _internal_mutable_datas()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::space_service::AoiUpdate>* AoiUpdates::mutable_datas()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:space_service.AoiUpdates.datas)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_datas();
}
inline const ::space_service::AoiUpdate& AoiUpdates::datas(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:space_service.AoiUpdates.datas)
  return _internal_datas().Get(index);
}
inline ::space_service::AoiUpdate* AoiUpdates::add_datas() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::space_service::AoiUpdate* _add = _internal_mutable_datas()->Add();
  // @@protoc_insertion_point(field_add:space_service.AoiUpdates.datas)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::space_service::AoiUpdate>& AoiUpdates::datas() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:space_service.AoiUpdates.datas)
  return _internal_datas();
}
inline const ::google::protobuf::RepeatedPtrField<::space_service::AoiUpdate>&
AoiUpdates::_internal_datas() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.datas_;
}
inline ::google::protobuf::RepeatedPtrField<::space_service::AoiUpdate>*
AoiUpdates::_internal_mutable_datas() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.datas_;
}

// -------------------------------------------------------------------

// Ping

// float t = 1;
inline void Ping::clear_t() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.t_ = 0;
}
inline float Ping::t() const {
  // @@protoc_insertion_point(field_get:space_service.Ping.t)
  return _internal_t();
}
inline void Ping::set_t(float value) {
  _internal_set_t(value);
  // @@protoc_insertion_point(field_set:space_service.Ping.t)
}
inline float Ping::_internal_t() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.t_;
}
inline void Ping::_internal_set_t(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.t_ = value;
}

// -------------------------------------------------------------------

// Pong

// float t = 1;
inline void Pong::clear_t() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.t_ = 0;
}
inline float Pong::t() const {
  // @@protoc_insertion_point(field_get:space_service.Pong.t)
  return _internal_t();
}
inline void Pong::set_t(float value) {
  _internal_set_t(value);
  // @@protoc_insertion_point(field_set:space_service.Pong.t)
}
inline float Pong::_internal_t() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.t_;
}
inline void Pong::_internal_set_t(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.t_ = value;
}

// int32 server_t = 2;
inline void Pong::clear_server_t() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.server_t_ = 0;
}
inline ::int32_t Pong::server_t() const {
  // @@protoc_insertion_point(field_get:space_service.Pong.server_t)
  return _internal_server_t();
}
inline void Pong::set_server_t(::int32_t value) {
  _internal_set_server_t(value);
  // @@protoc_insertion_point(field_set:space_service.Pong.server_t)
}
inline ::int32_t Pong::_internal_server_t() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.server_t_;
}
inline void Pong::_internal_set_server_t(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.server_t_ = value;
}

// -------------------------------------------------------------------

// NormalAttack

// int32 combo = 1;
inline void NormalAttack::clear_combo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.combo_ = 0;
}
inline ::int32_t NormalAttack::combo() const {
  // @@protoc_insertion_point(field_get:space_service.NormalAttack.combo)
  return _internal_combo();
}
inline void NormalAttack::set_combo(::int32_t value) {
  _internal_set_combo(value);
  // @@protoc_insertion_point(field_set:space_service.NormalAttack.combo)
}
inline ::int32_t NormalAttack::_internal_combo() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.combo_;
}
inline void NormalAttack::_internal_set_combo(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.combo_ = value;
}

// -------------------------------------------------------------------

// SkillAttack

// int32 skill_id = 1;
inline void SkillAttack::clear_skill_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.skill_id_ = 0;
}
inline ::int32_t SkillAttack::skill_id() const {
  // @@protoc_insertion_point(field_get:space_service.SkillAttack.skill_id)
  return _internal_skill_id();
}
inline void SkillAttack::set_skill_id(::int32_t value) {
  _internal_set_skill_id(value);
  // @@protoc_insertion_point(field_set:space_service.SkillAttack.skill_id)
}
inline ::int32_t SkillAttack::_internal_skill_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.skill_id_;
}
inline void SkillAttack::_internal_set_skill_id(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.skill_id_ = value;
}

// -------------------------------------------------------------------

// Animation

// string name = 1;
inline void Animation::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Animation::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:space_service.Animation.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Animation::set_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:space_service.Animation.name)
}
inline std::string* Animation::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:space_service.Animation.name)
  return _s;
}
inline const std::string& Animation::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void Animation::_internal_set_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(value, GetArena());
}
inline std::string* Animation::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* Animation::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:space_service.Animation.name)
  return _impl_.name_.Release();
}
inline void Animation::set_allocated_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:space_service.Animation.name)
}

// .space_service.Animation.OperationType op = 2;
inline void Animation::clear_op() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.op_ = 0;
}
inline ::space_service::Animation_OperationType Animation::op() const {
  // @@protoc_insertion_point(field_get:space_service.Animation.op)
  return _internal_op();
}
inline void Animation::set_op(::space_service::Animation_OperationType value) {
  _internal_set_op(value);
  // @@protoc_insertion_point(field_set:space_service.Animation.op)
}
inline ::space_service::Animation_OperationType Animation::_internal_op() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::space_service::Animation_OperationType>(_impl_.op_);
}
inline void Animation::_internal_set_op(::space_service::Animation_OperationType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.op_ = value;
}

// float speed = 3;
inline void Animation::clear_speed() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.speed_ = 0;
}
inline float Animation::speed() const {
  // @@protoc_insertion_point(field_get:space_service.Animation.speed)
  return _internal_speed();
}
inline void Animation::set_speed(float value) {
  _internal_set_speed(value);
  // @@protoc_insertion_point(field_set:space_service.Animation.speed)
}
inline float Animation::_internal_speed() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.speed_;
}
inline void Animation::_internal_set_speed(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.speed_ = value;
}

// -------------------------------------------------------------------

// PlayerAnimation

// int32 eid = 1;
inline void PlayerAnimation::clear_eid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.eid_ = 0;
}
inline ::int32_t PlayerAnimation::eid() const {
  // @@protoc_insertion_point(field_get:space_service.PlayerAnimation.eid)
  return _internal_eid();
}
inline void PlayerAnimation::set_eid(::int32_t value) {
  _internal_set_eid(value);
  // @@protoc_insertion_point(field_set:space_service.PlayerAnimation.eid)
}
inline ::int32_t PlayerAnimation::_internal_eid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.eid_;
}
inline void PlayerAnimation::_internal_set_eid(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.eid_ = value;
}

// .space_service.Animation data = 2;
inline bool PlayerAnimation::has_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.data_ != nullptr);
  return value;
}
inline void PlayerAnimation::clear_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.data_ != nullptr) _impl_.data_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::space_service::Animation& PlayerAnimation::_internal_data() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::space_service::Animation* p = _impl_.data_;
  return p != nullptr ? *p : reinterpret_cast<const ::space_service::Animation&>(::space_service::_Animation_default_instance_);
}
inline const ::space_service::Animation& PlayerAnimation::data() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:space_service.PlayerAnimation.data)
  return _internal_data();
}
inline void PlayerAnimation::unsafe_arena_set_allocated_data(::space_service::Animation* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.data_);
  }
  _impl_.data_ = reinterpret_cast<::space_service::Animation*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:space_service.PlayerAnimation.data)
}
inline ::space_service::Animation* PlayerAnimation::release_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::space_service::Animation* released = _impl_.data_;
  _impl_.data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::space_service::Animation* PlayerAnimation::unsafe_arena_release_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:space_service.PlayerAnimation.data)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::space_service::Animation* temp = _impl_.data_;
  _impl_.data_ = nullptr;
  return temp;
}
inline ::space_service::Animation* PlayerAnimation::_internal_mutable_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.data_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::space_service::Animation>(GetArena());
    _impl_.data_ = reinterpret_cast<::space_service::Animation*>(p);
  }
  return _impl_.data_;
}
inline ::space_service::Animation* PlayerAnimation::mutable_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::space_service::Animation* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:space_service.PlayerAnimation.data)
  return _msg;
}
inline void PlayerAnimation::set_allocated_data(::space_service::Animation* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.data_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.data_ = reinterpret_cast<::space_service::Animation*>(value);
  // @@protoc_insertion_point(field_set_allocated:space_service.PlayerAnimation.data)
}

// -------------------------------------------------------------------

// TakeDamage

// int32 eid = 1;
inline void TakeDamage::clear_eid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.eid_ = 0;
}
inline ::int32_t TakeDamage::eid() const {
  // @@protoc_insertion_point(field_get:space_service.TakeDamage.eid)
  return _internal_eid();
}
inline void TakeDamage::set_eid(::int32_t value) {
  _internal_set_eid(value);
  // @@protoc_insertion_point(field_set:space_service.TakeDamage.eid)
}
inline ::int32_t TakeDamage::_internal_eid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.eid_;
}
inline void TakeDamage::_internal_set_eid(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.eid_ = value;
}

// int32 damage = 2;
inline void TakeDamage::clear_damage() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.damage_ = 0;
}
inline ::int32_t TakeDamage::damage() const {
  // @@protoc_insertion_point(field_get:space_service.TakeDamage.damage)
  return _internal_damage();
}
inline void TakeDamage::set_damage(::int32_t value) {
  _internal_set_damage(value);
  // @@protoc_insertion_point(field_set:space_service.TakeDamage.damage)
}
inline ::int32_t TakeDamage::_internal_damage() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.damage_;
}
inline void TakeDamage::_internal_set_damage(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.damage_ = value;
}

// -------------------------------------------------------------------

// QueryPath

// .space_service.Vector3f start_pos = 1;
inline bool QueryPath::has_start_pos() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.start_pos_ != nullptr);
  return value;
}
inline void QueryPath::clear_start_pos() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.start_pos_ != nullptr) _impl_.start_pos_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::space_service::Vector3f& QueryPath::_internal_start_pos() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::space_service::Vector3f* p = _impl_.start_pos_;
  return p != nullptr ? *p : reinterpret_cast<const ::space_service::Vector3f&>(::space_service::_Vector3f_default_instance_);
}
inline const ::space_service::Vector3f& QueryPath::start_pos() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:space_service.QueryPath.start_pos)
  return _internal_start_pos();
}
inline void QueryPath::unsafe_arena_set_allocated_start_pos(::space_service::Vector3f* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.start_pos_);
  }
  _impl_.start_pos_ = reinterpret_cast<::space_service::Vector3f*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:space_service.QueryPath.start_pos)
}
inline ::space_service::Vector3f* QueryPath::release_start_pos() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::space_service::Vector3f* released = _impl_.start_pos_;
  _impl_.start_pos_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::space_service::Vector3f* QueryPath::unsafe_arena_release_start_pos() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:space_service.QueryPath.start_pos)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::space_service::Vector3f* temp = _impl_.start_pos_;
  _impl_.start_pos_ = nullptr;
  return temp;
}
inline ::space_service::Vector3f* QueryPath::_internal_mutable_start_pos() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.start_pos_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::space_service::Vector3f>(GetArena());
    _impl_.start_pos_ = reinterpret_cast<::space_service::Vector3f*>(p);
  }
  return _impl_.start_pos_;
}
inline ::space_service::Vector3f* QueryPath::mutable_start_pos() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::space_service::Vector3f* _msg = _internal_mutable_start_pos();
  // @@protoc_insertion_point(field_mutable:space_service.QueryPath.start_pos)
  return _msg;
}
inline void QueryPath::set_allocated_start_pos(::space_service::Vector3f* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.start_pos_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.start_pos_ = reinterpret_cast<::space_service::Vector3f*>(value);
  // @@protoc_insertion_point(field_set_allocated:space_service.QueryPath.start_pos)
}

// .space_service.Vector3f end_pos = 2;
inline bool QueryPath::has_end_pos() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.end_pos_ != nullptr);
  return value;
}
inline void QueryPath::clear_end_pos() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.end_pos_ != nullptr) _impl_.end_pos_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::space_service::Vector3f& QueryPath::_internal_end_pos() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::space_service::Vector3f* p = _impl_.end_pos_;
  return p != nullptr ? *p : reinterpret_cast<const ::space_service::Vector3f&>(::space_service::_Vector3f_default_instance_);
}
inline const ::space_service::Vector3f& QueryPath::end_pos() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:space_service.QueryPath.end_pos)
  return _internal_end_pos();
}
inline void QueryPath::unsafe_arena_set_allocated_end_pos(::space_service::Vector3f* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.end_pos_);
  }
  _impl_.end_pos_ = reinterpret_cast<::space_service::Vector3f*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:space_service.QueryPath.end_pos)
}
inline ::space_service::Vector3f* QueryPath::release_end_pos() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::space_service::Vector3f* released = _impl_.end_pos_;
  _impl_.end_pos_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::space_service::Vector3f* QueryPath::unsafe_arena_release_end_pos() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:space_service.QueryPath.end_pos)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::space_service::Vector3f* temp = _impl_.end_pos_;
  _impl_.end_pos_ = nullptr;
  return temp;
}
inline ::space_service::Vector3f* QueryPath::_internal_mutable_end_pos() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.end_pos_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::space_service::Vector3f>(GetArena());
    _impl_.end_pos_ = reinterpret_cast<::space_service::Vector3f*>(p);
  }
  return _impl_.end_pos_;
}
inline ::space_service::Vector3f* QueryPath::mutable_end_pos() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::space_service::Vector3f* _msg = _internal_mutable_end_pos();
  // @@protoc_insertion_point(field_mutable:space_service.QueryPath.end_pos)
  return _msg;
}
inline void QueryPath::set_allocated_end_pos(::space_service::Vector3f* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.end_pos_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.end_pos_ = reinterpret_cast<::space_service::Vector3f*>(value);
  // @@protoc_insertion_point(field_set_allocated:space_service.QueryPath.end_pos)
}

// -------------------------------------------------------------------

// QueryPathResult

// repeated .space_service.Vector3f paths = 1;
inline int QueryPathResult::_internal_paths_size() const {
  return _internal_paths().size();
}
inline int QueryPathResult::paths_size() const {
  return _internal_paths_size();
}
inline void QueryPathResult::clear_paths() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.paths_.Clear();
}
inline ::space_service::Vector3f* QueryPathResult::mutable_paths(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:space_service.QueryPathResult.paths)
  return _internal_mutable_paths()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::space_service::Vector3f>* QueryPathResult::mutable_paths()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:space_service.QueryPathResult.paths)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_paths();
}
inline const ::space_service::Vector3f& QueryPathResult::paths(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:space_service.QueryPathResult.paths)
  return _internal_paths().Get(index);
}
inline ::space_service::Vector3f* QueryPathResult::add_paths() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::space_service::Vector3f* _add = _internal_mutable_paths()->Add();
  // @@protoc_insertion_point(field_add:space_service.QueryPathResult.paths)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::space_service::Vector3f>& QueryPathResult::paths() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:space_service.QueryPathResult.paths)
  return _internal_paths();
}
inline const ::google::protobuf::RepeatedPtrField<::space_service::Vector3f>&
QueryPathResult::_internal_paths() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.paths_;
}
inline ::google::protobuf::RepeatedPtrField<::space_service::Vector3f>*
QueryPathResult::_internal_mutable_paths() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.paths_;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace space_service


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::space_service::Animation_OperationType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::space_service::Animation_OperationType>() {
  return ::space_service::Animation_OperationType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_space_5fservice_2eproto_2epb_2eh
